## Лабораторная работа №9

Знакомство с PostgreSQL

## Цель работы

Ознакомиться с СУБД PostgreSQL. Рассмотреть некоторые базовые типы данных в PostgreSQL и познакомится с ограничениями-проверками. 

## Ход работы

У меня есть две новости, одна хорошая, вторая тоже. 

Первой стоит знать, что 99% запросов, которые мы писали ранее для MySQL прекрасно будут работать и в PostgreSQL.

Второе для PostgreSQL есть документация на русском языке https://postgrespro.ru/docs/postgresql/13/index.

### А теперь кратко о PostgreSQL:

PostgreSQL — это объектно-реляционная система управления базами данных (ОРСУБД, ORDBMS), основанная на [POSTGRES, Version 4.2](https://dsf.berkeley.edu/postgres.html) — программе, разработанной на факультете компьютерных наук  Калифорнийского университета в Беркли. В POSTGRES появилось множество  новшеств, которые были реализованы в некоторых коммерческих СУБД гораздо позднее.

PostgreSQL — СУБД с  открытым исходным кодом, основой которого был код, написанный в Беркли.  Она поддерживает большую часть стандарта SQL и предлагает множество  современных функций: 

- сложные запросы
- внешние ключи
- триггеры
- изменяемые представления
- транзакционная целостность
- многоверсионность

 Кроме того, пользователи могут всячески расширять возможности PostgreSQL, например создавая свои 

- типы данных
- функции
- операторы
- агрегатные функции
- методы индексирования
- процедурные языки

А благодаря свободной лицензии, PostgreSQL разрешается бесплатно использовать, изменять и распространять всем и для любых целей — личных, коммерческих или учебных.



### Типы данных в PostgreSQL



#### Числовые типы

##### Целочисленные типы

Типы `smallint`, `integer` и `bigint` хранят целые числа, то есть числа без дробной части, имеющие разные  допустимые диапазоны. Попытка сохранить значение, выходящее за рамки  диапазона, приведёт к ошибке.

Чаще всего используется тип `integer`, как наиболее сбалансированный выбор ширины диапазона, размера и быстродействия. Тип `smallint` обычно применяется, только когда крайне важно уменьшить размер данных на диске. Тип `bigint` предназначен для тех случаев, когда числа не умещаются в диапазон типа `integer`.

В SQL определены только типы `integer` (или `int`), `smallint` и `bigint`. Имена типов `int2`, `int4` и `int8` выходят за рамки стандарта, хотя могут работать и в некоторых других СУБД.



#### Числа с произвольной точностью

Тип `numeric` позволяет хранить числа с очень большим количеством цифр. Он особенно  рекомендуется для хранения <u>денежных сумм</u> и других величин, где важна точность. Вычисления с типом `numeric` дают точные результаты, где это возможно, например, при сложении, вычитании и умножении. Однако операции со значениями `numeric` <u>выполняются гораздо медленнее</u>, чем с целыми числами или с типами с плавающей точкой.

Ниже мы используем следующие термины: *точность* значения `numeric` определяет общее количество значащих цифр во всём числе, то есть количество цифр с двух сторон от десятичной точки. *Масштаб* `numeric` определяет количество десятичных цифр в дробной части, справа от  десятичной точки. Например, число 23.5141 имеет точность 6 и масштаб 4.  

Для столбца типа `numeric` можно настроить и максимальную точность, и максимальный масштаб. Столбец типа `numeric` объявляется следующим образом: 

```
NUMERIC(точность, масштаб)
```

 Точность должна быть положительной, а масштаб положительным или равным нулю. Альтернативный вариант 

```
NUMERIC(точность)
```

 устанавливает масштаб 0. Форма: 

```
NUMERIC
```

 без указания точности и масштаба создаёт столбец, в котором можно  сохранять числовые значения любой точности и масштаба в пределах,  поддерживаемых системой. В столбце этого типа входные значения не будут  приводиться к какому-либо масштабу, тогда как в столбцах `numeric` с явно заданным масштабом значения подгоняются под этот масштаб. (Стандарт SQL утверждает, что по умолчанию должен устанавливаться масштаб 0, т. е.  значения должны приводиться к целым числам. Однако мы считаем это не  очень полезным. Если для вас важна переносимость, всегда указывайте  точность и масштаб явно.)

**Примечание:**

Максимально допустимая точность, которую можно указать в объявлении типа, равна 1000; если же использовать `NUMERIC` без указания точности, действуют ограничения, описанные в [Таблице 8.2](#Таблица-82-Числовые-типы).



#### Типы с плавающей точкой

Типы данных `real` и `double precision` хранят приближённые числовые значения с переменной точностью. На практике эти типы обычно реализуют стандарт IEEE 754 для двоичной арифметики с плавающей точкой (с одинарной и двойной  точностью соответственно), в той мере, в какой его поддерживают  процессор, операционная система и компилятор.

Неточность здесь  выражается в том, что некоторые значения, которые нельзя преобразовать  во внутренний формат, сохраняются приближённо, так что полученное  значение может несколько отличаться от записанного. Управление подобными ошибками и их распространение в процессе вычислений является предметом  изучения целого раздела математики и компьютерной науки, и здесь не  рассматривается. Мы отметим только следующее: 

- Если вам нужна точность при хранении и вычислениях (например, для денежных сумм), используйте вместо этого тип `numeric`.
- Если вы хотите выполнять с этими типами сложные вычисления, имеющие большую  важность, тщательно изучите реализацию операций в вашей среде и особенно поведение в крайних случаях (бесконечность, антипереполнение).
- Проверка равенства двух чисел с плавающей точкой может не всегда давать ожидаемый результат.

На большинстве платформ тип `real` может сохранить значения в пределах от 1E-37 до 1E+37 с точностью не меньше 6 десятичных цифр. Тип `double precision` предлагает значения в диапазоне от 1E-307 до 1E+308 и с точностью не  меньше 15 цифр. Попытка сохранить слишком большие или слишком маленькие  значения приведёт к ошибке. Если точность вводимого числа слишком  велика, оно будет округлено. При попытке сохранить число, близкое к 0,  но непредставимое как отличное от 0, произойдёт ошибка антипереполнения.

В дополнение к обычным числовым значениям типы с плавающей точкой могут содержать следующие специальные значения: 


`Infinity`
`-Infinity`
`NaN`

 Они представляют особые значения, описанные в IEEE 754, соответственно «бесконечность», «минус бесконечность» и «не число». (На компьютерах, где арифметика с плавающей точкой не соответствует  стандарту IEEE 754, эти значения, вероятно, не будут работать должным  образом.) Записывая эти значения в виде констант в команде SQL, их нужно заключать в апострофы, например так: `UPDATE table SET x = 'Infinity'`. Регистр символов в этих строках не важен.



#### Последовательные типы



Типы данных `smallserial`, `serial` и `bigserial` не являются настоящими типами, а представляют собой просто удобное  средство для создания столбцов с уникальными идентификаторами (подобное  свойству `AUTO_INCREMENT` в некоторых СУБД). В текущей реализации запись: 

```
CREATE TABLE имя_таблицы (
    имя_столбца SERIAL
);
```

 равнозначна следующим командам: 

```
CREATE SEQUENCE имя_таблицы_имя_столбца_seq;
CREATE TABLE имя_таблицы (
    имя_столбца integer NOT NULL DEFAULT nextval('имя_таблицы_имя_столбца_seq')
);
ALTER SEQUENCE имя_таблицы_имя_столбца_seq OWNED BY имя_таблицы.имя_столбца;
```

 То есть при определении такого типа создаётся целочисленный столбец со  значением по умолчанию, извлекаемым из генератора последовательности.  Чтобы в столбец нельзя было вставить NULL, в его определение добавляется ограничение `NOT NULL`. (Во многих случаях также имеет смысл добавить для этого столбца ограничения `UNIQUE` или `PRIMARY KEY` для защиты от ошибочного добавления дублирующихся значений, но  автоматически это не происходит.) Последняя команда определяет, что  последовательность «принадлежит» столбцу, так что она будет удалена при удалении столбца или таблицы.

Так как типы `smallserial`, `serial` и `bigserial` реализованы через последовательности, в числовом ряду значений столбца  могут образовываться пропуски (или «дыры»), даже если никакие строки не  удалялись. Значение, выделенное из последовательности, считается  «задействованным», даже если строку с этим значением не удалось вставить в таблицу. Это может произойти, например, при откате транзакции,  добавляющей данные.

##### **Таблица 8.2. Числовые типы**

| Имя                | Размер     | Описание                                  | Диапазон                                              |
| ------------------ | ---------- | ----------------------------------------- | ----------------------------------------------------- |
| `smallint`         | 2 байта    | целое в небольшом диапазоне               | -32768 .. +32767                                      |
| `integer`          | 4 байта    | типичный выбор для целых чисел            | -2147483648 .. +2147483647                            |
| `bigint`           | 8 байт     | целое в большом диапазоне                 | -9223372036854775808 .. 9223372036854775807           |
| `decimal`          | переменный | вещественное число с указанной точностью  | до 131072 цифр до десятичной точки и до 16383 — после |
| `numeric`          | переменный | вещественное число с указанной точностью  | до 131072 цифр до десятичной точки и до 16383 — после |
| `real`             | 4 байта    | вещественное число с переменной точностью | точность в пределах 6 десятичных цифр                 |
| `double precision` | 8 байт     | вещественное число с переменной точностью | точность в пределах 15 десятичных цифр                |
| `smallserial`      | 2 байта    | небольшое целое с автоувеличением         | 1 .. 32767                                            |
| `serial`           | 4 байта    | целое с автоувеличением                   | 1 .. 2147483647                                       |
| `bigserial`        | 8 байт     | большое целое с автоувеличением           | 1 .. 9223372036854775807                              |



#### Символьные типы

**Таблица 8.4. Символьные типы**

| Имя                                          | Описание                                          |
| -------------------------------------------- | ------------------------------------------------- |
| `character varying(*`n`*)`, `varchar(*`n`*)` | строка ограниченной переменной длины              |
| `character(*`n`*)`, `char(*`n`*)`            | строка фиксированной длины, дополненная пробелами |
| `text`                                       | строка неограниченной переменной длины            |

SQL определяет два основных символьных типа: `character varying(*`n`*)` и `character(*`n`*)`, где *`n`* — положительное число. Оба эти типа могут хранить текстовые строки длиной до *`n`* символов (не байт). Попытка сохранить в столбце такого типа более  длинную строку приведёт к ошибке, если только все лишние символы не  являются пробелами (тогда они будут усечены до максимально допустимой  длины). (Это несколько странное исключение продиктовано стандартом SQL.) Если длина сохраняемой строки оказывается меньше объявленной, значения типа `character` будут дополнятся пробелами; а тип `character varying` просто сохранит короткую строку.

При попытке явно привести значение к типу `character varying(*`n`*)` или `character(*`n`*)`, часть строки, выходящая за границу в *`n`* символов, удаляется, не вызывая ошибки. (Это также продиктовано стандартом SQL.)

Записи `varchar(*`n`*)` и `char(*`n`*)` являются синонимами `character varying(*`n`*)` и `character(*`n`*)`, соответственно. Записи `character` без указания длины соответствует `character(1)`. Если же длина не указывается для `character varying`, этот тип будет принимать строки любого размера. Это поведение является расширением PostgreSQL.



**Другие типы данных описаны тут:**

https://postgrespro.ru/docs/postgresql/9.6/datatype



### Ограничения-проверки

Ограничение-проверка — наиболее общий тип ограничений. В его  определении вы можете указать, что значение данного столбца должно  удовлетворять логическому выражению (проверке истинности). Например,  цену товара можно ограничить положительными значениями так: 

```sql
CREATE TABLE products (
    product_no serial PRIMARY KEY,
    name text,
    price numeric CHECK (price > 0)
);
```

Выполнение третье строки в скрипте ниже покажет ошибку `Schema Error: error: new row for relation "product" violates check constraint "product_price_check"`

```sql
INSERT INTO product(name, price) VALUES ('Компьютер Игровой', 40000.00);
INSERT INTO product(name, price) VALUES ('Компьютер Офисный', 120000.00);
--Выполнение вставки ниже вызовет ошибку
INSERT INTO product(name, price) VALUES ('Калькулятор Игровой', -120000.00); 
```

**Example here:**

https://www.db-fiddle.com/f/3qi9urcJzvq7WMgXLnwgQk/9

Как вы видите, ограничение определяется после типа данных, как и  значение по умолчанию. Значения по умолчанию и ограничения могут  указываться в любом порядке. Ограничение-проверка состоит из ключевого  слова `CHECK`, за которым идёт выражение в  скобках. Это выражение должно включать столбец, для которого задаётся  ограничение, иначе оно не имеет большого смысла.



### Ограничения-проверка с именем

Вы можете также присвоить ограничению отдельное имя. Это улучшит  сообщения об ошибках и позволит вам ссылаться на это ограничение, когда  вам понадобится изменить его. Сделать это можно так: 

```sql
CREATE TABLE product (
    product_no serial PRIMARY KEY,
    name text,
    price numeric CONSTRAINT positive_price CHECK (price > 0)
);
```

 То есть, чтобы создать именованное ограничение, напишите ключевое слово `CONSTRAINT`, а за ним идентификатор и собственно определение ограничения. (Если вы  не определите имя ограничения таким образом, система выберет для него  имя за вас.)



### Ограничение-проверка на несколько столбцов

Ограничение-проверка может также ссылаться на  несколько столбцов. Например, если вы храните обычную цену и цену со  скидкой, так вы можете гарантировать, что цена со скидкой будет всегда  меньше обычной: 

```sql
CREATE TABLE product (
    product_no serial PRIMARY KEY,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);
```



Первые два ограничения определяются похожим образом, но для третьего  используется новый синтаксис. Оно не связано с определённым столбцом, а  представлено отдельным элементом в списке. Определения столбцов и такие  определения ограничений можно переставлять в произвольном порядке.

Про первые два ограничения можно сказать, что это ограничения столбцов,  тогда как третье является ограничением таблицы, так как оно написано  отдельно от определений столбцов. Ограничения столбцов также можно  записать в виде ограничений таблицы, тогда как обратное не всегда  возможно, так как подразумевается, что ограничение столбца ссылается  только на связанный столбец. (Хотя PostgreSQL этого не требует, но для совместимости с другими СУБД лучше следовать  это правилу.) Ранее приведённый пример можно переписать и так: 

```sql
CREATE TABLE product (
    product_no serial PRIMARY KEY,
    name text,
    price numeric,
    CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);
```

 Или даже так: 

```sql
CREATE TABLE product (
    product_no serial PRIMARY KEY,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0 AND price > discounted_price)
);
```

 Это дело вкуса.

Ограничениям таблицы можно присваивать имена так же, как и ограничениям столбцов: 

```sql
CREATE TABLE product (
    product_no serial PRIMARY KEY,
    name text,
    price numeric,
    CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0),
    CONSTRAINT valid_discount CHECK (price > discounted_price)
);
```



## Задание 

Выполнять тут:

https://www.db-fiddle.com/ или  http://sqlfiddle.com/ или на вашей локальной машине, но все коды работ загрузить на соответствующий сервис.



### Вариант 1

Создать таблицу **student** 

Со следующими полями:

- full_name - ФИО студента 
- age - возраст
- rating - рейтинг

При этом поля должны иметь следующие характеристики:

- full_name - не пустое значение до 80 символов
- age - целое число от 0 до 150 не равное NULL
- rating - число от 0 до 100, с возможными двумя знаками после запятой, с повышенными требованиями по точности при вычислениях, не равное NULL

Заполнить таблицу 4-мя записями содержащие ФИО 4 **случайных** студента из <u>вашей группы</u>



### Вариант 2

Создать таблицу **airplane** 

Со следующими полями:

- model - модель самолёта
- max_speed - максимальная скорость
- max_passenger_count - максимальная загрузка самолёта пассажирами

При этом поля должны иметь следующие характеристики:

- model - не пустое значение до 40 символов
- max_speed -  число от 0 до 5000, с возможными двумя знаками после запятой, с повышенными требованиями по точности при вычислениях, не равное NULL
- max_passenger_count - целое число от 0 до 1200 не равное NULL

Заполнить таблицу 4-мя записями содержащие **случайно выбранные** модели 4 пассажирских самолётов 



## Требования к отчёту

1. Титульная страница 

   Титульная страница должна содержать:

   1. Наименование учебного учреждения
   2. Наименование предмета
   3. Фамилию и инициалы студента
   4. Фамилию и инициалы преподавателя принимающего работу
   5. **Номер индивидуального задания** (если имеется)

2. Цель работы

3. Выполнение задания

4. **Ссылка на работу** https://www.db-fiddle.com или http://sqlfiddle.com/ ссылка должна быть выделена **жирным текстом** и в тексте присутствовать полностью. Несмотря на предоставление ссылки на работу все коды программы должны полностью присутствовать в отчёте.

5. Выводы по работе